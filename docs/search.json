[
  {
    "objectID": "Project_1.html",
    "href": "Project_1.html",
    "title": "Project 1",
    "section": "",
    "text": "The purpose of Project One is to query, summarize, and display data using the census.gov API\n\n\n\nThe main workflow consists of\n\nCalling a function to get data from the API\nChecking the returned data meet criteria defined in the project specification\nGetting metadata for specified variables\nMapping classification levels for factor variables\nMapping time variables to the midpoint for times that have ranges and formatting in 24hour time format\nReturning a tibble of the API\nCalling a function that allows the user to specify multiple years of survey data when querying the API and returns results as a tibble\nMaking our previous tibble have an additional class of “census”\nCalling a function that produces means and standard deviations for numeric variable(s) and counts for categorical variable(s) in a named list\nCreate boxplot of selected variables:\n\nBox plot of Age (AGEP) by Sex\nBox plot of Broadband Access (HISPEED) by Sex\nBox plot of School Enrollment (SCH) by Age (AGEP) &lt; 30\nBox plot of Age &lt; 30 vs. School Enrollment by SEX\n\n\n\n\n\n\n\n\nWe created a few helper functions to ensure separation of concerns and modularity of code. The implementation of these functions is detailed below\n\n\n\nreturns data from an API call to census.gov as a tibble\n\n\n#return API query as tibble\nreturn_tibble &lt;- function (content)\n{\n  parsed_data &lt;- as_tibble(fromJSON(rawToChar(content)))\n  \n  #set column names from first row\n  col_names &lt;- parsed_data[1,]\n  parsed_data &lt;- parsed_data[-1,]\n  parsed_data &lt;- setNames(parsed_data, col_names) \n  \n  #save data to disk\n  # write_csv(parsed_data, \"raw_api.csv\")\n  return(parsed_data)  \n}\n\n\n\n\n\ndynamically gets variable metadata and returns a lookup table for specified variables in function get_PUMS\nthis function is currently of limited utility, but works for the current project.\nthe original idea was to create a metadata table from the project specification that could be used to lookup and drive the logic for data processing.\n\nIt needs work to be part of a consistent metadata driven approach, but works minimally for this project\n\n\n\n#get metadata from specification for user provided variables\n#metadata can be used for further checks, type conversion, and factor leveling\n#get_var_metadata currently checks for required variables in a user provided\n#function call, but no other checks\nget_var_metadata &lt;- function(var_list){\n  spec_vars &lt;- tibble(varname = c(\"PWGTP\",\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\n                                  \"JWMNP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\n                                  \"SCHL\",\"SEX\"),\n                      type = c(\"num\",\"num\",\"num\",\"num\",\"chr\",\"chr\",\"num\",\"chr\"\n                               ,\"chr\",\"chr\",\"chr\",\"chr\",\"chr\",\"chr\"),\n                      required = c(TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,\n                                   TRUE,TRUE,TRUE,TRUE,TRUE,TRUE),\n                      dt = c(FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,\n                             FALSE,FALSE,FALSE,FALSE)\n                      )\n  \n  #unlist user specified / API required vars to vector\n  if (!\"PWGTP\" %in% var_list){\n    var_list &lt;- c(var_list, \"PWGTP\")\n  }\n\n  var_list &lt;- unlist(str_split(var_list, \",\"))\n  var_list &lt;- str_trim(var_list)\n  var_list &lt;- var_list[var_list != \"\" & var_list != \" \"]\n\n\n  #return required varnames as a vector to use in quality checks\n  user_vars &lt;- spec_vars |&gt;\n    filter(varname %in% var_list)\n\n  #return tibble for varnames in user provided list. This is the lookup table to\n  #be used for checking variable types and factor levels\n  return(user_vars)\n  }\n\n\n\n\n\nchecks geography and year against specified values\n\n\ncheck_vars &lt;- function(user_vars, geography, year)\n{\n  year_range &lt;- seq(2010,2022, by = 1)\n  if (!geography %in% c(\"all\",\"region\",\"division\",\"state\")){\n    stop(paste(geography), \" is not an allowed value for the geography variable. Options are: all, region, division, state\")\n  } \n  if (!year %in% year_range){\n    stop(paste(year), \" is not an allowed value for the year variable. Options are between 2010 - 2022\")\n  } \n  else if (year == 2020){\n    stop(paste(year), \" is not available from census.gov\")\n  }\n  else{\n    return(TRUE)\n  }\n}\n\n\n\n\n\ngetter function gets factor levels and returns them as a list. Initial designs included this, but are not referenced in subsequent data processing steps. Kept as part of project for posterity\nsetter function checks, processes, and sets classification levels for factor variables.\n\nreturns a tibble\n\n\n\n#get factor levels\nget_pums_factor_levels &lt;- function(var_names){\n  print(var_names)\n  #initialize list\n  levels_list &lt;- list()\n  var_names &lt;- unlist(strsplit(var_names,\",\"))\n  print(var_names)\n  #get base URL\n  for (var_name in var_names){\n    url &lt;- paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/\",var_name,\".json\")\n    print(url)\n    response &lt;- GET(url)\n    if (status_code(response) == 200) {\n      data &lt;- fromJSON(content(response,\"text\"))\n      levels &lt;- data$values$item\n      levels_list[[var_name]] &lt;- levels\n    }\n  }\n  return(levels_list)\n}\n\n#get factor levels and set types\nset_factor_levels_types &lt;- function(data_tibble, var_tibbs) {\n  # Process character variables and set them as factors with levels\n  chr_vars &lt;- var_tibbs|&gt;\n    filter(type == \"chr\") |&gt;\n    pull(varname)\n  \n  # Loop through chr_vars and fetch levels for factor variables\n  data_tibble &lt;- data_tibble |&gt;\n    mutate(across(all_of(chr_vars), ~ {\n      var_name &lt;- cur_column()  # Get the current column name\n      url &lt;- paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/\", var_name, \".json\")\n\n      response &lt;- GET(url)\n      if (status_code(response) == 200) {\n        data &lt;- fromJSON(content(response, \"text\", encoding = \"UTF-8\"))\n        \n        if (!is.null(data$values) && \"item\" %in% names(data$values)) {\n          levels &lt;- names(data$values$item)\n          labels &lt;- data$values$item\n          return(factor(.x, levels = levels, labels = labels))\n          \n        } else {\n          warning(paste(\"Levels for\", var_name, \"not found in API response\"))\n          return(.x)  # Return unchanged column\n        }\n      } else {\n        warning(paste(\"Failed to fetch data for\", var_name, \": HTTP status\", status_code(response)))\n        return(.x)  # Return unchanged column\n      }\n    }))\n\n  # Process numeric variables and convert them to numeric\n  num_vars &lt;- var_tibbs |&gt;\n    filter(type == \"num\") |&gt;\n    pull(varname)\n\n  data_tibble &lt;- data_tibble |&gt; \n    mutate(across(all_of(num_vars), as.numeric))\n\n  return(data_tibble)\n}\n\n\n#Checks\n\n# x &lt;- get_pums_factor_levels(\"JWMNP\")\n# devdata_tibbs &lt;- pums_data$api_data\n# glimpse(devdata_tibbs)\n# devvar_tibbs &lt;- pums_data$api_metadata\n# glimpse(devvar_tibbs)\n# devx &lt;- set_factor_levels_types(devdata_tibbs, devvar_tibbs)\n\n# print(unique(devx$JWAP))\n# print(unique(devx$SEX))\n# print(unique(devx$FER))\n\n\n\n\n\nthese functions are dependent on one another. They convert factored time variables that contain a specific string pattern into a 24 hour time format representing the midpoint of the range\n\nExample: the factored string 3:00 p.m. to 3:04 p.m. would be returned from this function as 15:02\n\n\n\nextract_times &lt;- function(jwap_value){\n  # Handle N/A and missing cases\n  if (str_detect(as.character(jwap_value), \"N/A\") | \n      is.na(jwap_value) |\n      str_detect(as.character(jwap_value), \"NA\")) {\n        return(list(first_24 = \"NA\", second_24 = \"NA\"))\n  }\n  \n  # Split the string into parts (e.g., \"9:40 p.m. to 9:44 p.m.\")\n  parts &lt;- str_split(as.character(jwap_value), \" \")[[1]]\n  first_time &lt;- parts[1]\n  first_ampm &lt;- str_replace_all(parts[2], \"\\\\.\", \"\")\n  second_time &lt;- parts[4]\n  second_ampm &lt;- str_replace_all(parts[5], \"\\\\.\", \"\")\n  \n  # Convert both times to 24-hour format\n  first_24 &lt;- convert_to_24_hour(first_time, first_ampm)\n  second_24 &lt;- convert_to_24_hour(second_time, second_ampm)\n  \n  return(list(first_24 = first_24, second_24 = second_24))\n}\n\nconvert_to_24_hour &lt;- function(time_str, ampm_str) {\n  # Clean up the AM/PM string by removing periods\n  full_time_str &lt;- paste(time_str, ampm_str)  # Combine time and cleaned AM/PM\n  time_parsed &lt;- parse_date_time(full_time_str, \"I:M p\")  # Parse AM/PM time\n  return(format(time_parsed, \"%H:%M\"))  # Convert to 24-hour format\n  \n}\n\ncalculate_midpoint &lt;- function(time_parsed){\n  second_24 &lt;- as.POSIXct(time_parsed$second_24, format = \"%H:%M\")\n  first_24 &lt;- as.POSIXct(time_parsed$first_24, format = \"%H:%M\")\n  \n  #handle NA\n  if(is.na(second_24) | is.na(first_24)) {\n    return(NA)\n  }\n  \n  midpoint &lt;- first_24 + (second_24 - first_24)/2\n  # print(format(midpoint, \"%H:%M\"))\n  return(format(midpoint, \"%H:%M\"))\n}\n\n\n#Testing\n# df &lt;- pums_data$api_data |&gt;\n#   mutate(\n#     time_parsed = map(JWAP, extract_times),  # Extract times into a list of parsed times\n#     first_24 = map_chr(time_parsed, \"first_24\"),  # Extract first 24-hour time\n#     second_24 = map_chr(time_parsed, \"second_24\"),  # Extract second 24-hour time\n#     midpoint = map_chr(time_parsed, calculate_midpoint)  # Calculate midpoint between times\n#   )\n # filtered_data &lt;- pums_data$api_data |&gt;\n   # filter(str_detect(as.character(JWAP), \"N/A\") | is.na(JWAP) | str_detect(as.character(JWAP), \"NA\"))|&gt;\n   # filter(!(as.character(JWAP) %in% (c(\"N/A\",\"NA\", \"\", \" \")))) |&gt;\n   # slice_head(n=100)\n\n\n\n\n\nThis function serves as the function to get, check, factor, and format variables according to project specifications\n\n\nget_PUMS &lt;- function(geography, num_vars = NULL, chr_vars = NULL , key = sys.getenv(\"CENSUS_API_KEY\"),\n                             year = 2022, state = \"05\",county = NULL, zcta = NULL,\n                             survey = \"acs1\", show_call = FALSE)\n{\n  #munge var lists\n  if(is.null(num_vars)){\n    num_vars &lt;- c(\"PWGTP\", \"AGEP\")\n  }\n  if(is.null(chr_vars)){\n    chr_vars &lt;- c(\"SEX\")\n  }\n\n  user_vars &lt;-c(num_vars, chr_vars)\n\n  #get var metadata\n  var_metadata &lt;- get_var_metadata(user_vars)\n\n  #get vars string for API call after returning metadata\n  api_var_string &lt;- paste(var_metadata$varname,collapse = \",\")\n\n  #check vars values in range\n  var_check &lt;- check_vars(user_vars,geography,year)\n  # If check_vars returns a message (missing vars), stop the function\n  if (!isTRUE(var_check)) {\n    stop(var_check)  # Stops and prints the error message from check_vars\n  }\n\n  #get base URL\n  baseURL &lt;- paste(\"https://api.census.gov/data\",\n                   as.character(year), \"acs\",\n                   survey, \"pums\", sep = \"/\")\n\n\n  paramsURL &lt;- paste0(\"?get=\", api_var_string, \"&for=\", geography, \":\", state, \"&key=\", key)\n  apiURL &lt;- (paste0(baseURL,paramsURL))\n\n  #check\n  print(apiURL)\n\n  response &lt;- httr::GET(apiURL)\n\n  # Convert API response to a tibble |&gt;\n  #set factor levels and convert data types\n\n  parsed_data &lt;- return_tibble(response$content)\n  jwmnptst &lt;- return_tibble(response$content)\n  # |&gt;\n  #   clean_names()\n  # Set factor levels and types for the tibble\n\n  tst &lt;- set_factor_levels_types(parsed_data, var_metadata)\n  \n  parsed_data &lt;- set_factor_levels_types(parsed_data, var_metadata)\n  \n  # df &lt;- parsed_data$JWAP |&gt;\n  #     mutate(\n  #       time_parsed = map(JWAP, extract_times),  # Extract times\n  #       midpoint = map_chr(time_parsed, calculate_midpoint)  # Calculate midpoints\n  #     )\n  datetime_var_chk &lt;- c(\"JWAP\", \"JWDP\", \"JWMNT\")\n  \n  for (varname in datetime_var_chk){\n    if (varname %in% names(parsed_data)){\n      if (varname == \"JWAP\"){\n        parsed_data &lt;- parsed_data |&gt;\n          mutate(\n            JWAP = as.character(JWAP),\n            time_parsed = map(JWAP, extract_times),  # Extract times into a list of parsed times\n            first_24 = map_chr(time_parsed, \"first_24\"),  # Extract first 24-hour time\n            second_24 = map_chr(time_parsed, \"second_24\"),  # Extract second 24-hour time\n            midpoint = map_chr(time_parsed, calculate_midpoint)) |&gt;\n          rename(jwap_t = midpoint) |&gt;\n          select(-first_24, -second_24 , -time_parsed)\n      }\n      else if (varname == \"JWDP\"){\n        parsed_data &lt;- parsed_data |&gt;\n          mutate(\n            JWDP = as.character(JWDP),\n            time_parsed = map(JWDP, extract_times),  # Extract times into a list of parsed times\n            first_24 = map_chr(time_parsed, \"first_24\"),  # Extract first 24-hour time\n            second_24 = map_chr(time_parsed, \"second_24\"),  # Extract second 24-hour time\n            midpoint = map_chr(time_parsed, calculate_midpoint)) |&gt;\n          rename(jwdp_t = midpoint) |&gt;\n          select(-first_24, -second_24 , -time_parsed)\n      }\n      else if (varname == \"JWMNP\"){\n        parsed_data &lt;- parsed_data |&gt;\n          # filter(JWMNP == as.character(\"0\")) |&gt;\n          mutate(\n            jwmnp_c = as.character(JWMNP),\n            jwmnp_n = suppressWarnings(as.numeric(jwmnp_c)),  # Suppress warnings and handle NA conversion\n            jwmnp_mins = ifelse(is.na(jwmnp_n), NA, jwmnp_n)\n          ) |&gt;\n          select(-jwmnp_c, -jwmnp_n)\n      }\n    }\n}\n\n  #return a list with two tibbles\n  api_data &lt;- list(api_data = parsed_data, api_metadata = var_metadata, jwmnptst = jwmnptst, tst = tst)\n\n  return(api_data)\n}\n\n\n\n\nnum_vars &lt;- \"AGEP, GASP, GRPIP, JWAP, JWDP, JWMNP\"\nchr_vars &lt;- \"FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX\"\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyear &lt;- 2022\n\npums_data &lt;- get_PUMS(geography,num_vars,chr_vars,key,year,state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n\n\n\n\nnum_vars &lt;- NULL\nchr_vars &lt;- NULL\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyear &lt;- 2022\n\npums_data_default &lt;- get_PUMS(geography,num_vars,chr_vars,key,year,state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\n\n\n\n\n\n\n\n#glimpse the first 20 rows\npums_data$api_data |&gt;\n  head(20) |&gt;\n  glimpse()\n\nRows: 20\nColumns: 17\n$ PWGTP   &lt;dbl&gt; 48, 49, 59, 37, 22, 37, 38, 87, 50, 140, 13, 9, 5, 8, 6, 22, 2…\n$ AGEP    &lt;dbl&gt; 49, 19, 21, 55, 60, 52, 25, 93, 38, 52, 93, 16, 27, 23, 31, 20…\n$ GASP    &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n$ GRPIP   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n$ JWAP    &lt;chr&gt; \"N/A (not a worker; worker who worked from home)\", \"N/A (not a…\n$ JWDP    &lt;chr&gt; \"N/A (not a worker; worker who worked from home)\", \"N/A (not a…\n$ JWMNP   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0\n$ FER     &lt;fct&gt; N/A (less than 15 years/greater than 50 years/ male), No, No, …\n$ HHL     &lt;fct&gt; N/A (GQ/vacant), N/A (GQ/vacant), N/A (GQ/vacant), N/A (GQ/vac…\n$ HISPEED &lt;fct&gt; N/A (GQ/vacant/no paid access to the internet), N/A (GQ/vacant…\n$ JWTRNS  &lt;fct&gt; \"N/A (not a worker-not in the labor force, including persons u…\n$ SCH     &lt;fct&gt; \"No, has not attended in the last 3 months\", \"Yes, private sch…\n$ SCHL    &lt;fct&gt; \"Regular high school diploma\", \"Some college, but less than 1 …\n$ SEX     &lt;fct&gt; Male, Female, Female, Male, Female, Male, Male, Female, Male, …\n$ state   &lt;chr&gt; \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"0…\n$ jwap_t  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ jwdp_t  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\n\n\n\n\nfactor_vars &lt;- pums_data$api_data |&gt;\n  select(where(is.factor))\n\nfactor_vars |&gt; \n  map(unique)\n\n$FER\n[1] N/A (less than 15 years/greater than 50 years/ male)\n[2] No                                                  \n[3] Yes                                                 \nLevels: N/A (less than 15 years/greater than 50 years/ male) No Yes\n\n$HHL\n[1] N/A (GQ/vacant)                    English Only                      \n[3] Spanish                            Other Indo-European languages     \n[5] Asian and Pacific Island languages Other Language                    \n6 Levels: N/A (GQ/vacant) Spanish ... Other Language\n\n$HISPEED\n[1] N/A (GQ/vacant/no paid access to the internet)\n[2] Yes                                           \n[3] No                                            \nLevels: No Yes N/A (GQ/vacant/no paid access to the internet)\n\n$JWTRNS\n[1] N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)\n[2] Worked from home                                                                                                                                                       \n[3] Walked                                                                                                                                                                 \n[4] &lt;NA&gt;                                                                                                                                                                   \n[5] Other method                                                                                                                                                           \n13 Levels: Worked from home Taxicab Bus ... Motorcycle\n\n$SCH\n[1] No, has not attended in the last 3 months    \n[2] Yes, private school or college or home school\n[3] Yes, public school or public college         \n[4] N/A (less than 3 years old)                  \n4 Levels: N/A (less than 3 years old) ...\n\n$SCHL\n [1] Regular high school diploma                   \n [2] Some college, but less than 1 year            \n [3] 1 or more years of college credit, no degree  \n [4] &lt;NA&gt;                                          \n [5] GED or alternative credential                 \n [6] Associate's degree                            \n [7] 12th grade - no diploma                       \n [8] Grade 7                                       \n [9] Grade 9                                       \n[10] Grade 10                                      \n[11] Grade 11                                      \n[12] Master's degree                               \n[13] Professional degree beyond a bachelor's degree\n[14] Bachelor's degree                             \n[15] Grade 8                                       \n[16] Doctorate degree                              \n[17] N/A (less than 3 years old)                   \n25 Levels: Regular high school diploma No schooling completed ... Grade 6\n\n$SEX\n[1] Male   Female\nLevels: Male Female\n\n\n\n\n\n\n\nnum_vars &lt;- \"JWAP, JWDP, JWMNP\"\n# num_vars &lt;- NULL\n# chr_vars &lt;- \"FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX\"\nchr_vars &lt;- NULL\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyear &lt;- 2022\n\npums_data &lt;- get_PUMS(geography,num_vars,chr_vars,key,year,state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,JWAP,JWDP,JWMNP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\ntime_vars &lt;- pums_data$api_data |&gt;\n  select(jwap_t, jwdp_t) |&gt;\n  filter(!is.na(jwap_t) & !is.na(jwdp_t)) |&gt;\n  head(20) |&gt;\n  glimpse()\n\nRows: 20\nColumns: 2\n$ jwap_t &lt;chr&gt; \"14:37\", \"14:52\", \"18:02\", \"18:22\", \"17:17\", \"14:52\", \"14:27\", …\n$ jwdp_t &lt;chr&gt; \"14:04\", \"14:34\", \"17:34\", \"17:14\", \"16:44\", \"14:04\", \"14:04\", …\n\n\n\n\n\n\n\n\nPUMS_multi_year &lt;- function(geography, num_vars = NULL, chr_vars = NULL, years,\n                            key = Sys.getenv(\"CENSUS_API_KEY\"),\n                            state = \"*\", county = NULL, zcta = NULL,\n                            survey = \"acs1\", show_call = FALSE) {\n  \n  # Empty list to store data for each year\n  list_data &lt;- list()\n  \n  # Looping through each year and calling the get_PUMS function\n  for (year in years) {\n    year_data &lt;- get_PUMS(geography = geography,\n                          num_vars = num_vars,\n                          chr_vars = chr_vars,\n                          key = key,\n                          year = year,\n                          state = state,\n                          county = county,\n                          zcta = zcta,\n                          survey = survey,\n                          show_call = show_call)\n    \n    # Extract the 'api_data' part of the year_data list\n    year_data &lt;- year_data$api_data\n    \n    # Ensure year_data is a tibble/data.frame\n    if (is.list(year_data)) {\n      year_data &lt;- as_tibble(year_data)\n    }\n    \n    # Adding new column to data\n    year_data &lt;- year_data |&gt;\n      mutate(year = as.character(year))\n    \n    # Adding data for the year to our list\n    list_data[[as.character(year)]] &lt;- year_data\n  }\n  \n  # Combine all yearly data into a tibble\n  years_tibble &lt;- bind_rows(list_data)\n  \n  # Add a \"census\" class, workflow step 8\n  class(years_tibble) &lt;- c(\"census\", class(years_tibble))\n  \n  return(years_tibble)\n}\n\n\n\n\n# Testing PUMS_multi_year function\n\n# Defining specific years to query\nyears &lt;- c(2022, 2021)\nnum_vars &lt;- NULL\nchr_vars &lt;- NULL\nPUMS_multi_year_test &lt;- PUMS_multi_year(geography, num_vars, chr_vars, years, key, state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\nprint(unique(PUMS_multi_year_test$year))\n\n[1] \"2022\" \"2021\"\n\n\n\n\n\n\n\nsummary.census &lt;- function(tibble_class_census,\n                           numeric_variables = NULL,\n                           categorical_variables = NULL) {\n\n  # Selecting numerical variables\n  numeric_vector &lt;- names(select_if(tibble_class_census, is.numeric))\n\n  # Weight vector\n  weight_vector &lt;- as.numeric(tibble_class_census$PWGTP)\n\n  # Selecting categorical variables\n  categorical_vector &lt;- names(select_if(tibble_class_census, is.character))\n\n  # List to store census summary results\n  census_summary_results &lt;- list()\n\n  # Function to obtain weighted mean\n  weighted_mean &lt;- function(numeric_vector, weight_vector = NULL) {\n    if (!is.null(weight_vector)) {\n      return(sum(numeric_vector * weight_vector, na.rm = TRUE) /\n               sum(weight_vector, na.rm = TRUE))\n    } else {\n      return(mean(numeric_vector, na.rm = TRUE))\n    }\n  }\n\n  # Function to find weighted standard deviation\n  weighted_sd &lt;- function(numeric_vector, weight_vector = NULL) {\n    sample_mean &lt;- weighted_mean(numeric_vector, weight_vector)\n    if (!is.null(weight_vector)) {\n      return(sqrt(sum(weight_vector * (numeric_vector^2), na.rm = TRUE) /\n                    sum(weight_vector, na.rm = TRUE) - sample_mean^2))\n    } else {\n      return(sd(numeric_vector, na.rm = TRUE))\n    }\n  }\n\n  # Numeric summarizer\n  for (num_var in numeric_variables) {\n    var_data &lt;- as.numeric(tibble_class_census[[num_var]])\n    mean_val &lt;- weighted_mean(var_data, weight_vector)\n    sd_val &lt;- weighted_sd(var_data, weight_vector)\n\n    # Storing results in list\n    census_summary_results[[num_var]] &lt;- list(mean = mean_val, sd = sd_val)\n  }\n\n  # Categorical summarizer\n  for (cat_var in categorical_variables) {\n    counts &lt;- table(tibble_class_census[[cat_var]])\n    census_summary_results[[cat_var]] &lt;- counts\n  }\n\n  # Plotting a boxplot of numeric variable by categorical variable\n  if (!is.null(numeric_variables) && !is.null(categorical_variables)) {\n    for (num_var in numeric_variables) {\n      for (cat_var in categorical_variables) {\n        ggplot(tibble_class_census, aes(x = .data[[cat_var]], y = .data[[num_var]])) +\n          geom_boxplot() +\n          labs(title = paste(\"Boxplot of\", num_var, \"by\", cat_var),\n               x = cat_var,\n               y = num_var) +\n          theme_minimal() -&gt; plot\n\n        print(plot)  # Print the plot\n      }\n    }\n  }\n  else print(\"Not plotting\")\n\n  return(census_summary_results)\n}\n\n# Defining user variables\nnumeric_variables &lt;- c(\"PWGTP\", \"AGEP\")\ncategorical_variables &lt;- c(\"SEX\")\n\n# Testing Summarizer Function\ncensus_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n                                 numeric_variables = numeric_variables,\n                                 categorical_variables = categorical_variables)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Printing named lists of means, standard deviations, and categorical counts\nprint(census_summary)\n\n$PWGTP\n$PWGTP$mean\n[1] 189.7572\n\n$PWGTP$sd\n[1] 160.8471\n\n\n$AGEP\n$AGEP$mean\n[1] 39.19619\n\n$AGEP$sd\n[1] 23.55343\n\n\n$SEX\n\n  Male Female \n 30006  31332 \n\n#Defining user variables\n# numeric_variables &lt;- c(\"PWGTP\", \"AGEP\")\n# categorical_variables &lt;- c(\"SEX\")\n# \n# # Testing Summarizer Function\n# census_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n#                                  numeric_variables = numeric_variables,\n#                                  categorical_variables = categorical_variables)\n# # Printing named lists of means, standard deviations, and categorical counts\n# print(census_summary)\n\n\n\n\n# Assuming you have PUMS_multi_year_test as your data\ncensus_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n                                 numeric_variables = num_vars,\n                                 categorical_variables = chr_vars)\n\n[1] \"Not plotting\"\n\n# Printing named lists of means, standard deviations, and categorical counts\nprint(census_summary)\n\nlist()\n\n\n\n\n\n\n#Defining user variables\nnumeric_variables &lt;- c(\"PWGTP\", \"AGEP\")\ncategorical_variables &lt;- c(\"SEX\")\n# Testing Summarizer Function\ncensus_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n                                 numeric_variables = numeric_variables,\n                                 categorical_variables = categorical_variables)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Printing named lists of means, standard deviations, and categorical counts\nprint(census_summary)\n\n$PWGTP\n$PWGTP$mean\n[1] 189.7572\n\n$PWGTP$sd\n[1] 160.8471\n\n\n$AGEP\n$AGEP$mean\n[1] 39.19619\n\n$AGEP$sd\n[1] 23.55343\n\n\n$SEX\n\n  Male Female \n 30006  31332 \n\n\n\n\n\n\nnum_vars &lt;- c(\"AGEP\",\"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n# num_vars &lt;- NULL\nchr_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n# chr_vars &lt;- NULL\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyears &lt;- c(2022, 2021)\nPUMS_multi_year_test_all &lt;- PUMS_multi_year(geography, num_vars, chr_vars, years, key, state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\n# print(unique(PUMS_multi_year_test_all$year))\n\n\n\n\n\n\nggplot(PUMS_multi_year_test_all, aes(x = SEX, y = AGEP)) +\n  geom_boxplot() +\n  ggtitle(\"Box plot of Age (AGEP) by Sex\") +\n  theme_minimal()\n\n\n\n\n\n\n\nggplot(PUMS_multi_year_test_all, aes(x = HISPEED, y = AGEP)) +\n  geom_boxplot() +\n  ggtitle(\"Box plot of Broadband Access (HISPEED) by Sex\") +\n  theme_minimal()\n\n\n\n\n\n\n\nagep_lt30 &lt;- PUMS_multi_year_test_all |&gt;\n  filter(AGEP &lt; 30, !is.na(SCH))\n\nagep_lt30$SCH &lt;- recode(agep_lt30$SCH,\n                        \"N/A (less than 3 years old)\" = \"N/A (Age &lt; 3)\",\n                        \"Yes, private school or college or home school\" = \"Private/Home School\",\n                        \"No, has not attended in the last 3 months\" = \"Not Attending\",\n                        \"Yes, public school or public college\" = \"Public School\")\n\nagep_lt30$SCH &lt;- factor(agep_lt30$SCH)\n\nggplot(agep_lt30, aes(x = SCH, y = AGEP)) +\n  geom_boxplot() +\n  ggtitle(\"Box plot of School Enrollment (SCH) by Age (AGEP) &lt; 30\") +\n  theme_minimal()\n\n\n\n\n\n\n\nggplot(agep_lt30, aes(x = SCH , y = AGEP)) +\n  geom_boxplot() +\n  facet_wrap(~ SEX) +  # Create separate plots for each level of SEX\n  theme_minimal() +\n  ggtitle(\"Box plot of Age &lt; 30 vs. School Enrollment by SEX\")"
  },
  {
    "objectID": "Project_1.html#project-1",
    "href": "Project_1.html#project-1",
    "title": "Project 1",
    "section": "",
    "text": "The purpose of Project One is to query, summarize, and display data using the census.gov API\n\n\n\nThe main workflow consists of\n\nCalling a function to get data from the API\nChecking the returned data meet criteria defined in the project specification\nGetting metadata for specified variables\nMapping classification levels for factor variables\nMapping time variables to the midpoint for times that have ranges and formatting in 24hour time format\nReturning a tibble of the API\nCalling a function that allows the user to specify multiple years of survey data when querying the API and returns results as a tibble\nMaking our previous tibble have an additional class of “census”\nCalling a function that produces means and standard deviations for numeric variable(s) and counts for categorical variable(s) in a named list\nCreate boxplot of selected variables:\n\nBox plot of Age (AGEP) by Sex\nBox plot of Broadband Access (HISPEED) by Sex\nBox plot of School Enrollment (SCH) by Age (AGEP) &lt; 30\nBox plot of Age &lt; 30 vs. School Enrollment by SEX\n\n\n\n\n\n\n\n\nWe created a few helper functions to ensure separation of concerns and modularity of code. The implementation of these functions is detailed below\n\n\n\nreturns data from an API call to census.gov as a tibble\n\n\n#return API query as tibble\nreturn_tibble &lt;- function (content)\n{\n  parsed_data &lt;- as_tibble(fromJSON(rawToChar(content)))\n  \n  #set column names from first row\n  col_names &lt;- parsed_data[1,]\n  parsed_data &lt;- parsed_data[-1,]\n  parsed_data &lt;- setNames(parsed_data, col_names) \n  \n  #save data to disk\n  # write_csv(parsed_data, \"raw_api.csv\")\n  return(parsed_data)  \n}\n\n\n\n\n\ndynamically gets variable metadata and returns a lookup table for specified variables in function get_PUMS\nthis function is currently of limited utility, but works for the current project.\nthe original idea was to create a metadata table from the project specification that could be used to lookup and drive the logic for data processing.\n\nIt needs work to be part of a consistent metadata driven approach, but works minimally for this project\n\n\n\n#get metadata from specification for user provided variables\n#metadata can be used for further checks, type conversion, and factor leveling\n#get_var_metadata currently checks for required variables in a user provided\n#function call, but no other checks\nget_var_metadata &lt;- function(var_list){\n  spec_vars &lt;- tibble(varname = c(\"PWGTP\",\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\n                                  \"JWMNP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\n                                  \"SCHL\",\"SEX\"),\n                      type = c(\"num\",\"num\",\"num\",\"num\",\"chr\",\"chr\",\"num\",\"chr\"\n                               ,\"chr\",\"chr\",\"chr\",\"chr\",\"chr\",\"chr\"),\n                      required = c(TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,\n                                   TRUE,TRUE,TRUE,TRUE,TRUE,TRUE),\n                      dt = c(FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,\n                             FALSE,FALSE,FALSE,FALSE)\n                      )\n  \n  #unlist user specified / API required vars to vector\n  if (!\"PWGTP\" %in% var_list){\n    var_list &lt;- c(var_list, \"PWGTP\")\n  }\n\n  var_list &lt;- unlist(str_split(var_list, \",\"))\n  var_list &lt;- str_trim(var_list)\n  var_list &lt;- var_list[var_list != \"\" & var_list != \" \"]\n\n\n  #return required varnames as a vector to use in quality checks\n  user_vars &lt;- spec_vars |&gt;\n    filter(varname %in% var_list)\n\n  #return tibble for varnames in user provided list. This is the lookup table to\n  #be used for checking variable types and factor levels\n  return(user_vars)\n  }\n\n\n\n\n\nchecks geography and year against specified values\n\n\ncheck_vars &lt;- function(user_vars, geography, year)\n{\n  year_range &lt;- seq(2010,2022, by = 1)\n  if (!geography %in% c(\"all\",\"region\",\"division\",\"state\")){\n    stop(paste(geography), \" is not an allowed value for the geography variable. Options are: all, region, division, state\")\n  } \n  if (!year %in% year_range){\n    stop(paste(year), \" is not an allowed value for the year variable. Options are between 2010 - 2022\")\n  } \n  else if (year == 2020){\n    stop(paste(year), \" is not available from census.gov\")\n  }\n  else{\n    return(TRUE)\n  }\n}\n\n\n\n\n\ngetter function gets factor levels and returns them as a list. Initial designs included this, but are not referenced in subsequent data processing steps. Kept as part of project for posterity\nsetter function checks, processes, and sets classification levels for factor variables.\n\nreturns a tibble\n\n\n\n#get factor levels\nget_pums_factor_levels &lt;- function(var_names){\n  print(var_names)\n  #initialize list\n  levels_list &lt;- list()\n  var_names &lt;- unlist(strsplit(var_names,\",\"))\n  print(var_names)\n  #get base URL\n  for (var_name in var_names){\n    url &lt;- paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/\",var_name,\".json\")\n    print(url)\n    response &lt;- GET(url)\n    if (status_code(response) == 200) {\n      data &lt;- fromJSON(content(response,\"text\"))\n      levels &lt;- data$values$item\n      levels_list[[var_name]] &lt;- levels\n    }\n  }\n  return(levels_list)\n}\n\n#get factor levels and set types\nset_factor_levels_types &lt;- function(data_tibble, var_tibbs) {\n  # Process character variables and set them as factors with levels\n  chr_vars &lt;- var_tibbs|&gt;\n    filter(type == \"chr\") |&gt;\n    pull(varname)\n  \n  # Loop through chr_vars and fetch levels for factor variables\n  data_tibble &lt;- data_tibble |&gt;\n    mutate(across(all_of(chr_vars), ~ {\n      var_name &lt;- cur_column()  # Get the current column name\n      url &lt;- paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/\", var_name, \".json\")\n\n      response &lt;- GET(url)\n      if (status_code(response) == 200) {\n        data &lt;- fromJSON(content(response, \"text\", encoding = \"UTF-8\"))\n        \n        if (!is.null(data$values) && \"item\" %in% names(data$values)) {\n          levels &lt;- names(data$values$item)\n          labels &lt;- data$values$item\n          return(factor(.x, levels = levels, labels = labels))\n          \n        } else {\n          warning(paste(\"Levels for\", var_name, \"not found in API response\"))\n          return(.x)  # Return unchanged column\n        }\n      } else {\n        warning(paste(\"Failed to fetch data for\", var_name, \": HTTP status\", status_code(response)))\n        return(.x)  # Return unchanged column\n      }\n    }))\n\n  # Process numeric variables and convert them to numeric\n  num_vars &lt;- var_tibbs |&gt;\n    filter(type == \"num\") |&gt;\n    pull(varname)\n\n  data_tibble &lt;- data_tibble |&gt; \n    mutate(across(all_of(num_vars), as.numeric))\n\n  return(data_tibble)\n}\n\n\n#Checks\n\n# x &lt;- get_pums_factor_levels(\"JWMNP\")\n# devdata_tibbs &lt;- pums_data$api_data\n# glimpse(devdata_tibbs)\n# devvar_tibbs &lt;- pums_data$api_metadata\n# glimpse(devvar_tibbs)\n# devx &lt;- set_factor_levels_types(devdata_tibbs, devvar_tibbs)\n\n# print(unique(devx$JWAP))\n# print(unique(devx$SEX))\n# print(unique(devx$FER))\n\n\n\n\n\nthese functions are dependent on one another. They convert factored time variables that contain a specific string pattern into a 24 hour time format representing the midpoint of the range\n\nExample: the factored string 3:00 p.m. to 3:04 p.m. would be returned from this function as 15:02\n\n\n\nextract_times &lt;- function(jwap_value){\n  # Handle N/A and missing cases\n  if (str_detect(as.character(jwap_value), \"N/A\") | \n      is.na(jwap_value) |\n      str_detect(as.character(jwap_value), \"NA\")) {\n        return(list(first_24 = \"NA\", second_24 = \"NA\"))\n  }\n  \n  # Split the string into parts (e.g., \"9:40 p.m. to 9:44 p.m.\")\n  parts &lt;- str_split(as.character(jwap_value), \" \")[[1]]\n  first_time &lt;- parts[1]\n  first_ampm &lt;- str_replace_all(parts[2], \"\\\\.\", \"\")\n  second_time &lt;- parts[4]\n  second_ampm &lt;- str_replace_all(parts[5], \"\\\\.\", \"\")\n  \n  # Convert both times to 24-hour format\n  first_24 &lt;- convert_to_24_hour(first_time, first_ampm)\n  second_24 &lt;- convert_to_24_hour(second_time, second_ampm)\n  \n  return(list(first_24 = first_24, second_24 = second_24))\n}\n\nconvert_to_24_hour &lt;- function(time_str, ampm_str) {\n  # Clean up the AM/PM string by removing periods\n  full_time_str &lt;- paste(time_str, ampm_str)  # Combine time and cleaned AM/PM\n  time_parsed &lt;- parse_date_time(full_time_str, \"I:M p\")  # Parse AM/PM time\n  return(format(time_parsed, \"%H:%M\"))  # Convert to 24-hour format\n  \n}\n\ncalculate_midpoint &lt;- function(time_parsed){\n  second_24 &lt;- as.POSIXct(time_parsed$second_24, format = \"%H:%M\")\n  first_24 &lt;- as.POSIXct(time_parsed$first_24, format = \"%H:%M\")\n  \n  #handle NA\n  if(is.na(second_24) | is.na(first_24)) {\n    return(NA)\n  }\n  \n  midpoint &lt;- first_24 + (second_24 - first_24)/2\n  # print(format(midpoint, \"%H:%M\"))\n  return(format(midpoint, \"%H:%M\"))\n}\n\n\n#Testing\n# df &lt;- pums_data$api_data |&gt;\n#   mutate(\n#     time_parsed = map(JWAP, extract_times),  # Extract times into a list of parsed times\n#     first_24 = map_chr(time_parsed, \"first_24\"),  # Extract first 24-hour time\n#     second_24 = map_chr(time_parsed, \"second_24\"),  # Extract second 24-hour time\n#     midpoint = map_chr(time_parsed, calculate_midpoint)  # Calculate midpoint between times\n#   )\n # filtered_data &lt;- pums_data$api_data |&gt;\n   # filter(str_detect(as.character(JWAP), \"N/A\") | is.na(JWAP) | str_detect(as.character(JWAP), \"NA\"))|&gt;\n   # filter(!(as.character(JWAP) %in% (c(\"N/A\",\"NA\", \"\", \" \")))) |&gt;\n   # slice_head(n=100)\n\n\n\n\n\nThis function serves as the function to get, check, factor, and format variables according to project specifications\n\n\nget_PUMS &lt;- function(geography, num_vars = NULL, chr_vars = NULL , key = sys.getenv(\"CENSUS_API_KEY\"),\n                             year = 2022, state = \"05\",county = NULL, zcta = NULL,\n                             survey = \"acs1\", show_call = FALSE)\n{\n  #munge var lists\n  if(is.null(num_vars)){\n    num_vars &lt;- c(\"PWGTP\", \"AGEP\")\n  }\n  if(is.null(chr_vars)){\n    chr_vars &lt;- c(\"SEX\")\n  }\n\n  user_vars &lt;-c(num_vars, chr_vars)\n\n  #get var metadata\n  var_metadata &lt;- get_var_metadata(user_vars)\n\n  #get vars string for API call after returning metadata\n  api_var_string &lt;- paste(var_metadata$varname,collapse = \",\")\n\n  #check vars values in range\n  var_check &lt;- check_vars(user_vars,geography,year)\n  # If check_vars returns a message (missing vars), stop the function\n  if (!isTRUE(var_check)) {\n    stop(var_check)  # Stops and prints the error message from check_vars\n  }\n\n  #get base URL\n  baseURL &lt;- paste(\"https://api.census.gov/data\",\n                   as.character(year), \"acs\",\n                   survey, \"pums\", sep = \"/\")\n\n\n  paramsURL &lt;- paste0(\"?get=\", api_var_string, \"&for=\", geography, \":\", state, \"&key=\", key)\n  apiURL &lt;- (paste0(baseURL,paramsURL))\n\n  #check\n  print(apiURL)\n\n  response &lt;- httr::GET(apiURL)\n\n  # Convert API response to a tibble |&gt;\n  #set factor levels and convert data types\n\n  parsed_data &lt;- return_tibble(response$content)\n  jwmnptst &lt;- return_tibble(response$content)\n  # |&gt;\n  #   clean_names()\n  # Set factor levels and types for the tibble\n\n  tst &lt;- set_factor_levels_types(parsed_data, var_metadata)\n  \n  parsed_data &lt;- set_factor_levels_types(parsed_data, var_metadata)\n  \n  # df &lt;- parsed_data$JWAP |&gt;\n  #     mutate(\n  #       time_parsed = map(JWAP, extract_times),  # Extract times\n  #       midpoint = map_chr(time_parsed, calculate_midpoint)  # Calculate midpoints\n  #     )\n  datetime_var_chk &lt;- c(\"JWAP\", \"JWDP\", \"JWMNT\")\n  \n  for (varname in datetime_var_chk){\n    if (varname %in% names(parsed_data)){\n      if (varname == \"JWAP\"){\n        parsed_data &lt;- parsed_data |&gt;\n          mutate(\n            JWAP = as.character(JWAP),\n            time_parsed = map(JWAP, extract_times),  # Extract times into a list of parsed times\n            first_24 = map_chr(time_parsed, \"first_24\"),  # Extract first 24-hour time\n            second_24 = map_chr(time_parsed, \"second_24\"),  # Extract second 24-hour time\n            midpoint = map_chr(time_parsed, calculate_midpoint)) |&gt;\n          rename(jwap_t = midpoint) |&gt;\n          select(-first_24, -second_24 , -time_parsed)\n      }\n      else if (varname == \"JWDP\"){\n        parsed_data &lt;- parsed_data |&gt;\n          mutate(\n            JWDP = as.character(JWDP),\n            time_parsed = map(JWDP, extract_times),  # Extract times into a list of parsed times\n            first_24 = map_chr(time_parsed, \"first_24\"),  # Extract first 24-hour time\n            second_24 = map_chr(time_parsed, \"second_24\"),  # Extract second 24-hour time\n            midpoint = map_chr(time_parsed, calculate_midpoint)) |&gt;\n          rename(jwdp_t = midpoint) |&gt;\n          select(-first_24, -second_24 , -time_parsed)\n      }\n      else if (varname == \"JWMNP\"){\n        parsed_data &lt;- parsed_data |&gt;\n          # filter(JWMNP == as.character(\"0\")) |&gt;\n          mutate(\n            jwmnp_c = as.character(JWMNP),\n            jwmnp_n = suppressWarnings(as.numeric(jwmnp_c)),  # Suppress warnings and handle NA conversion\n            jwmnp_mins = ifelse(is.na(jwmnp_n), NA, jwmnp_n)\n          ) |&gt;\n          select(-jwmnp_c, -jwmnp_n)\n      }\n    }\n}\n\n  #return a list with two tibbles\n  api_data &lt;- list(api_data = parsed_data, api_metadata = var_metadata, jwmnptst = jwmnptst, tst = tst)\n\n  return(api_data)\n}\n\n\n\n\nnum_vars &lt;- \"AGEP, GASP, GRPIP, JWAP, JWDP, JWMNP\"\nchr_vars &lt;- \"FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX\"\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyear &lt;- 2022\n\npums_data &lt;- get_PUMS(geography,num_vars,chr_vars,key,year,state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n\n\n\n\nnum_vars &lt;- NULL\nchr_vars &lt;- NULL\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyear &lt;- 2022\n\npums_data_default &lt;- get_PUMS(geography,num_vars,chr_vars,key,year,state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\n\n\n\n\n\n\n\n#glimpse the first 20 rows\npums_data$api_data |&gt;\n  head(20) |&gt;\n  glimpse()\n\nRows: 20\nColumns: 17\n$ PWGTP   &lt;dbl&gt; 48, 49, 59, 37, 22, 37, 38, 87, 50, 140, 13, 9, 5, 8, 6, 22, 2…\n$ AGEP    &lt;dbl&gt; 49, 19, 21, 55, 60, 52, 25, 93, 38, 52, 93, 16, 27, 23, 31, 20…\n$ GASP    &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n$ GRPIP   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n$ JWAP    &lt;chr&gt; \"N/A (not a worker; worker who worked from home)\", \"N/A (not a…\n$ JWDP    &lt;chr&gt; \"N/A (not a worker; worker who worked from home)\", \"N/A (not a…\n$ JWMNP   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0\n$ FER     &lt;fct&gt; N/A (less than 15 years/greater than 50 years/ male), No, No, …\n$ HHL     &lt;fct&gt; N/A (GQ/vacant), N/A (GQ/vacant), N/A (GQ/vacant), N/A (GQ/vac…\n$ HISPEED &lt;fct&gt; N/A (GQ/vacant/no paid access to the internet), N/A (GQ/vacant…\n$ JWTRNS  &lt;fct&gt; \"N/A (not a worker-not in the labor force, including persons u…\n$ SCH     &lt;fct&gt; \"No, has not attended in the last 3 months\", \"Yes, private sch…\n$ SCHL    &lt;fct&gt; \"Regular high school diploma\", \"Some college, but less than 1 …\n$ SEX     &lt;fct&gt; Male, Female, Female, Male, Female, Male, Male, Female, Male, …\n$ state   &lt;chr&gt; \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"05\", \"0…\n$ jwap_t  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ jwdp_t  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\n\n\n\n\nfactor_vars &lt;- pums_data$api_data |&gt;\n  select(where(is.factor))\n\nfactor_vars |&gt; \n  map(unique)\n\n$FER\n[1] N/A (less than 15 years/greater than 50 years/ male)\n[2] No                                                  \n[3] Yes                                                 \nLevels: N/A (less than 15 years/greater than 50 years/ male) No Yes\n\n$HHL\n[1] N/A (GQ/vacant)                    English Only                      \n[3] Spanish                            Other Indo-European languages     \n[5] Asian and Pacific Island languages Other Language                    \n6 Levels: N/A (GQ/vacant) Spanish ... Other Language\n\n$HISPEED\n[1] N/A (GQ/vacant/no paid access to the internet)\n[2] Yes                                           \n[3] No                                            \nLevels: No Yes N/A (GQ/vacant/no paid access to the internet)\n\n$JWTRNS\n[1] N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)\n[2] Worked from home                                                                                                                                                       \n[3] Walked                                                                                                                                                                 \n[4] &lt;NA&gt;                                                                                                                                                                   \n[5] Other method                                                                                                                                                           \n13 Levels: Worked from home Taxicab Bus ... Motorcycle\n\n$SCH\n[1] No, has not attended in the last 3 months    \n[2] Yes, private school or college or home school\n[3] Yes, public school or public college         \n[4] N/A (less than 3 years old)                  \n4 Levels: N/A (less than 3 years old) ...\n\n$SCHL\n [1] Regular high school diploma                   \n [2] Some college, but less than 1 year            \n [3] 1 or more years of college credit, no degree  \n [4] &lt;NA&gt;                                          \n [5] GED or alternative credential                 \n [6] Associate's degree                            \n [7] 12th grade - no diploma                       \n [8] Grade 7                                       \n [9] Grade 9                                       \n[10] Grade 10                                      \n[11] Grade 11                                      \n[12] Master's degree                               \n[13] Professional degree beyond a bachelor's degree\n[14] Bachelor's degree                             \n[15] Grade 8                                       \n[16] Doctorate degree                              \n[17] N/A (less than 3 years old)                   \n25 Levels: Regular high school diploma No schooling completed ... Grade 6\n\n$SEX\n[1] Male   Female\nLevels: Male Female\n\n\n\n\n\n\n\nnum_vars &lt;- \"JWAP, JWDP, JWMNP\"\n# num_vars &lt;- NULL\n# chr_vars &lt;- \"FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX\"\nchr_vars &lt;- NULL\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyear &lt;- 2022\n\npums_data &lt;- get_PUMS(geography,num_vars,chr_vars,key,year,state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,JWAP,JWDP,JWMNP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\ntime_vars &lt;- pums_data$api_data |&gt;\n  select(jwap_t, jwdp_t) |&gt;\n  filter(!is.na(jwap_t) & !is.na(jwdp_t)) |&gt;\n  head(20) |&gt;\n  glimpse()\n\nRows: 20\nColumns: 2\n$ jwap_t &lt;chr&gt; \"14:37\", \"14:52\", \"18:02\", \"18:22\", \"17:17\", \"14:52\", \"14:27\", …\n$ jwdp_t &lt;chr&gt; \"14:04\", \"14:34\", \"17:34\", \"17:14\", \"16:44\", \"14:04\", \"14:04\", …\n\n\n\n\n\n\n\n\nPUMS_multi_year &lt;- function(geography, num_vars = NULL, chr_vars = NULL, years,\n                            key = Sys.getenv(\"CENSUS_API_KEY\"),\n                            state = \"*\", county = NULL, zcta = NULL,\n                            survey = \"acs1\", show_call = FALSE) {\n  \n  # Empty list to store data for each year\n  list_data &lt;- list()\n  \n  # Looping through each year and calling the get_PUMS function\n  for (year in years) {\n    year_data &lt;- get_PUMS(geography = geography,\n                          num_vars = num_vars,\n                          chr_vars = chr_vars,\n                          key = key,\n                          year = year,\n                          state = state,\n                          county = county,\n                          zcta = zcta,\n                          survey = survey,\n                          show_call = show_call)\n    \n    # Extract the 'api_data' part of the year_data list\n    year_data &lt;- year_data$api_data\n    \n    # Ensure year_data is a tibble/data.frame\n    if (is.list(year_data)) {\n      year_data &lt;- as_tibble(year_data)\n    }\n    \n    # Adding new column to data\n    year_data &lt;- year_data |&gt;\n      mutate(year = as.character(year))\n    \n    # Adding data for the year to our list\n    list_data[[as.character(year)]] &lt;- year_data\n  }\n  \n  # Combine all yearly data into a tibble\n  years_tibble &lt;- bind_rows(list_data)\n  \n  # Add a \"census\" class, workflow step 8\n  class(years_tibble) &lt;- c(\"census\", class(years_tibble))\n  \n  return(years_tibble)\n}\n\n\n\n\n# Testing PUMS_multi_year function\n\n# Defining specific years to query\nyears &lt;- c(2022, 2021)\nnum_vars &lt;- NULL\nchr_vars &lt;- NULL\nPUMS_multi_year_test &lt;- PUMS_multi_year(geography, num_vars, chr_vars, years, key, state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\nprint(unique(PUMS_multi_year_test$year))\n\n[1] \"2022\" \"2021\"\n\n\n\n\n\n\n\nsummary.census &lt;- function(tibble_class_census,\n                           numeric_variables = NULL,\n                           categorical_variables = NULL) {\n\n  # Selecting numerical variables\n  numeric_vector &lt;- names(select_if(tibble_class_census, is.numeric))\n\n  # Weight vector\n  weight_vector &lt;- as.numeric(tibble_class_census$PWGTP)\n\n  # Selecting categorical variables\n  categorical_vector &lt;- names(select_if(tibble_class_census, is.character))\n\n  # List to store census summary results\n  census_summary_results &lt;- list()\n\n  # Function to obtain weighted mean\n  weighted_mean &lt;- function(numeric_vector, weight_vector = NULL) {\n    if (!is.null(weight_vector)) {\n      return(sum(numeric_vector * weight_vector, na.rm = TRUE) /\n               sum(weight_vector, na.rm = TRUE))\n    } else {\n      return(mean(numeric_vector, na.rm = TRUE))\n    }\n  }\n\n  # Function to find weighted standard deviation\n  weighted_sd &lt;- function(numeric_vector, weight_vector = NULL) {\n    sample_mean &lt;- weighted_mean(numeric_vector, weight_vector)\n    if (!is.null(weight_vector)) {\n      return(sqrt(sum(weight_vector * (numeric_vector^2), na.rm = TRUE) /\n                    sum(weight_vector, na.rm = TRUE) - sample_mean^2))\n    } else {\n      return(sd(numeric_vector, na.rm = TRUE))\n    }\n  }\n\n  # Numeric summarizer\n  for (num_var in numeric_variables) {\n    var_data &lt;- as.numeric(tibble_class_census[[num_var]])\n    mean_val &lt;- weighted_mean(var_data, weight_vector)\n    sd_val &lt;- weighted_sd(var_data, weight_vector)\n\n    # Storing results in list\n    census_summary_results[[num_var]] &lt;- list(mean = mean_val, sd = sd_val)\n  }\n\n  # Categorical summarizer\n  for (cat_var in categorical_variables) {\n    counts &lt;- table(tibble_class_census[[cat_var]])\n    census_summary_results[[cat_var]] &lt;- counts\n  }\n\n  # Plotting a boxplot of numeric variable by categorical variable\n  if (!is.null(numeric_variables) && !is.null(categorical_variables)) {\n    for (num_var in numeric_variables) {\n      for (cat_var in categorical_variables) {\n        ggplot(tibble_class_census, aes(x = .data[[cat_var]], y = .data[[num_var]])) +\n          geom_boxplot() +\n          labs(title = paste(\"Boxplot of\", num_var, \"by\", cat_var),\n               x = cat_var,\n               y = num_var) +\n          theme_minimal() -&gt; plot\n\n        print(plot)  # Print the plot\n      }\n    }\n  }\n  else print(\"Not plotting\")\n\n  return(census_summary_results)\n}\n\n# Defining user variables\nnumeric_variables &lt;- c(\"PWGTP\", \"AGEP\")\ncategorical_variables &lt;- c(\"SEX\")\n\n# Testing Summarizer Function\ncensus_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n                                 numeric_variables = numeric_variables,\n                                 categorical_variables = categorical_variables)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Printing named lists of means, standard deviations, and categorical counts\nprint(census_summary)\n\n$PWGTP\n$PWGTP$mean\n[1] 189.7572\n\n$PWGTP$sd\n[1] 160.8471\n\n\n$AGEP\n$AGEP$mean\n[1] 39.19619\n\n$AGEP$sd\n[1] 23.55343\n\n\n$SEX\n\n  Male Female \n 30006  31332 \n\n#Defining user variables\n# numeric_variables &lt;- c(\"PWGTP\", \"AGEP\")\n# categorical_variables &lt;- c(\"SEX\")\n# \n# # Testing Summarizer Function\n# census_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n#                                  numeric_variables = numeric_variables,\n#                                  categorical_variables = categorical_variables)\n# # Printing named lists of means, standard deviations, and categorical counts\n# print(census_summary)\n\n\n\n\n# Assuming you have PUMS_multi_year_test as your data\ncensus_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n                                 numeric_variables = num_vars,\n                                 categorical_variables = chr_vars)\n\n[1] \"Not plotting\"\n\n# Printing named lists of means, standard deviations, and categorical counts\nprint(census_summary)\n\nlist()\n\n\n\n\n\n\n#Defining user variables\nnumeric_variables &lt;- c(\"PWGTP\", \"AGEP\")\ncategorical_variables &lt;- c(\"SEX\")\n# Testing Summarizer Function\ncensus_summary &lt;- summary.census(tibble_class_census = PUMS_multi_year_test,\n                                 numeric_variables = numeric_variables,\n                                 categorical_variables = categorical_variables)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Printing named lists of means, standard deviations, and categorical counts\nprint(census_summary)\n\n$PWGTP\n$PWGTP$mean\n[1] 189.7572\n\n$PWGTP$sd\n[1] 160.8471\n\n\n$AGEP\n$AGEP$mean\n[1] 39.19619\n\n$AGEP$sd\n[1] 23.55343\n\n\n$SEX\n\n  Male Female \n 30006  31332 \n\n\n\n\n\n\nnum_vars &lt;- c(\"AGEP\",\"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n# num_vars &lt;- NULL\nchr_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n# chr_vars &lt;- NULL\ngeography &lt;- \"state\"\nkey &lt;- \"bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\nstate &lt;- \"05\"  # Arkansas\nyears &lt;- c(2022, 2021)\nPUMS_multi_year_test_all &lt;- PUMS_multi_year(geography, num_vars, chr_vars, years, key, state)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:05&key=bdb1f6ff2e4982a1da64cd526532aa92dca5581c\"\n\n# print(unique(PUMS_multi_year_test_all$year))\n\n\n\n\n\n\nggplot(PUMS_multi_year_test_all, aes(x = SEX, y = AGEP)) +\n  geom_boxplot() +\n  ggtitle(\"Box plot of Age (AGEP) by Sex\") +\n  theme_minimal()\n\n\n\n\n\n\n\nggplot(PUMS_multi_year_test_all, aes(x = HISPEED, y = AGEP)) +\n  geom_boxplot() +\n  ggtitle(\"Box plot of Broadband Access (HISPEED) by Sex\") +\n  theme_minimal()\n\n\n\n\n\n\n\nagep_lt30 &lt;- PUMS_multi_year_test_all |&gt;\n  filter(AGEP &lt; 30, !is.na(SCH))\n\nagep_lt30$SCH &lt;- recode(agep_lt30$SCH,\n                        \"N/A (less than 3 years old)\" = \"N/A (Age &lt; 3)\",\n                        \"Yes, private school or college or home school\" = \"Private/Home School\",\n                        \"No, has not attended in the last 3 months\" = \"Not Attending\",\n                        \"Yes, public school or public college\" = \"Public School\")\n\nagep_lt30$SCH &lt;- factor(agep_lt30$SCH)\n\nggplot(agep_lt30, aes(x = SCH, y = AGEP)) +\n  geom_boxplot() +\n  ggtitle(\"Box plot of School Enrollment (SCH) by Age (AGEP) &lt; 30\") +\n  theme_minimal()\n\n\n\n\n\n\n\nggplot(agep_lt30, aes(x = SCH , y = AGEP)) +\n  geom_boxplot() +\n  facet_wrap(~ SEX) +  # Create separate plots for each level of SEX\n  theme_minimal() +\n  ggtitle(\"Box plot of Age &lt; 30 vs. School Enrollment by SEX\")"
  },
  {
    "objectID": "Untitled.html#running-code",
    "href": "Untitled.html#running-code",
    "title": "test",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "Untitled-1.html",
    "href": "Untitled-1.html",
    "title": "Project1",
    "section": "",
    "text": "The purpose of Project One is to query, summarize, and display data using the census.gov API.\n\n\n\nThe main workflow consists of:\n\nCalling a function to get data from the API\nChecking the returned data meet criteria defined in the project specification\nGetting metadata for specified variables\nMapping classification levels for factor variables\nMapping time variables to the midpoint for times that have ranges and formatting in 24-hour time format\nReturning a tibble of the API\n&lt;@Ethan&gt;\n&lt;@Ethan&gt;\n…"
  },
  {
    "objectID": "Untitled-1.html#project-1",
    "href": "Untitled-1.html#project-1",
    "title": "Project1",
    "section": "",
    "text": "The purpose of Project One is to query, summarize, and display data using the census.gov API.\n\n\n\nThe main workflow consists of:\n\nCalling a function to get data from the API\nChecking the returned data meet criteria defined in the project specification\nGetting metadata for specified variables\nMapping classification levels for factor variables\nMapping time variables to the midpoint for times that have ranges and formatting in 24-hour time format\nReturning a tibble of the API\n&lt;@Ethan&gt;\n&lt;@Ethan&gt;\n…"
  }
]